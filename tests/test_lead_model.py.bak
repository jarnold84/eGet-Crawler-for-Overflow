# tests/test_lead_model.py
import pytest
from models.lead import Lead


# --------------------------------------------------------------------- #
# 1️⃣ Core setters + provenance (your original tests, kept verbatim)
# --------------------------------------------------------------------- #
def test_happy_path():
    """All setters store the value and record the source URL."""
    lead = Lead()
    lead.set_name("Alice Example", "https://site.com/profile/alice")
    lead.set_email("alice@example.com", "https://site.com/profile/alice")
    lead.set_phone("+1‑555‑123‑4567", "https://site.com/contact")

    # Stored values
    assert lead.name == "Alice Example"
    assert lead.email == "alice@example.com"
    assert lead.phone == "+1‑555‑123‑4567"

    # Provenance dict
    assert lead.source_urls["name"] == ["https://site.com/profile/alice"]
    assert lead.source_urls["email"] == ["https://site.com/profile/alice"]
    assert lead.source_urls["phone"] == ["https://site.com/contact"]


def test_duplicate_url_not_added():
    """Calling a setter twice with the same URL should not duplicate it."""
    lead = Lead()
    url = "https://example.com/profile"
    lead.set_email("a@b.com", url)
    lead.set_email("a@b.com", url)   # same URL again

    # Only one entry should exist
    assert lead.source_urls["email"] == [url]


def test_missing_optional_fields_are_none():
    """Fields we never set stay as None and have no provenance entry."""
    lead = Lead()
    assert lead.name is None
    assert "name" not in lead.source_urls


# --------------------------------------------------------------------- #
# 2️⃣ Additional behaviours required by the spec
# --------------------------------------------------------------------- #
def test_is_three_source_valid_various_combinations():
    """Validate the helper that checks for ≥ 2 distinct contact channels."""
    # ── only email → False
    lead = Lead()
    lead.set_email("e@x.com", "u")
    assert not lead.is_three_source_valid()

    # ── email + phone → True
    lead.set_phone("123", "u")
    assert lead.is_three_source_valid()

    # ── reset, email + social → True
    lead = Lead()
    lead.set_email("e@x.com", "u")
    lead.set_social_handles({"instagram": "https://insta.com/e"}, "u")
    assert lead.is_three_source_valid()

    # ── only social (no email/phone) → False
    lead = Lead()
    lead.set_social_handles({"twitter": "https://t.co/x"}, "u")
    assert not lead.is_three_source_valid()


def test_whitespace_trimming_and_empty_string_to_none():
    """The generic validator should strip spaces and turn '' into None."""
    lead = Lead()
    lead.set_name("   Trim Me   ", "u")
    assert lead.name == "Trim Me"               # spaces removed

    # Empty string becomes None and does NOT create provenance
    lead.set_email("", "u")
    assert lead.email is None
    assert "email" not in lead.source_urls


def test_social_handle_provenance_per_platform():
    """Each social platform gets its own URL list under source_urls."""
    lead = Lead()
    lead.set_social_handles(
        {"instagram": "https://insta.com/me", "twitter": "https://t.co/me"},
        "https://src.com/profile",
    )
    # Top‑level key
    assert "socialHandles" in lead.source_urls
    # Platform‑specific lists
    assert lead.source_urls["socialHandles"]["instagram"] == ["https://src.com/profile"]
    assert lead.source_urls["socialHandles"]["twitter"] == ["https://src.com/profile"]


def test_email_format_validation_raises():
    """A badly‑formed email should raise a ValueError."""
    lead = Lead()
    with pytest.raises(ValueError):
        lead.set_email("not-an-email", "u")


def test_to_dict_excludes_none_fields():
    """`to_dict()` should drop any attribute that is still None."""
    lead = Lead()
    lead.set_name("Bob", "u")
    payload = lead.to_dict()
    # `email` and `phone` are omitted entirely
    assert "email" not in payload
    assert "phone" not in payload
    # `name` is present
    assert payload["name"] == "Bob"
    # provenance for name is kept
    assert payload["source_urls"]["name"] == ["u"]
